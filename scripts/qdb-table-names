#!/usr/bin/env bash
set -euo pipefail

# Regex matching UUID-4 with either dashes or underscores
UUID_REGEX='[0-9a-f]{8}([-_][0-9a-f]{4}){3}[-_][0-9a-f]{12}'

print_help() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [regex]

Get a list of table names or full table info from QuestDB, with filtering options.

Filtering Options:
  regex                Positional argument: Regex pattern to match table names (uses '~').
  -v, --inverse-match  Use inverse regex match ('!~') for the positional regex.
  -u, --uuid           Only tables containing a UUID-4 in their name.
  -U, --no-uuid        Only tables NOT containing a UUID-4 in their name. Mutually exclusive with -u.
  -P, --partitionBy P  Filter by partitioning strategy. P is a comma-separated list
                       (no spaces) of values like NONE,YEAR,MONTH,DAY,HOUR,WEEK.
                       Example: -P YEAR,MONTH
  -t, --has-designated-timestamp
                       Only tables that have a designated timestamp column. Mutually exclusive with -T.
  -T, --no-designated-timestamp
                       Only tables that do NOT have a designated timestamp column. Mutually exclusive with -t.
  -d, --dedup-enabled  Only tables with deduplication enabled. Mutually exclusive with -D.
  -D, --dedup-disabled Only tables with deduplication disabled. Mutually exclusive with -d.
  -l, --min-length N   Only tables with name length >= N.
  -L, --max-length N   Only tables with name length <= N.

Output Options:
  -f, --full-cols      Show all columns from the 'tables' table in PSQL format.
                       (Default: shows only table names, one per line)
  -h, --help           Show this help message and exit

Examples:
  # list all table names (default)
  $(basename "$0")

  # list tables NOT matching 'backup_'
  $(basename "$0") -v backup_

  # list tables partitioned by YEAR or MONTH
  $(basename "$0") -P YEAR,MONTH

  # list WAL tables with deduplication enabled and a designated timestamp
  $(basename "$0") -d -t

  # show full info for tables starting with 'trade', partitioned by DAY
  $(basename "$0") -f -P DAY trades_
EOF
}

# --- Option Parsing ---
# Defaults
uuid_flag=false
no_uuid_flag=false
full_cols_flag=false
inverse_match_flag=false
partition_by_filter=""
ts_filter=""    # Can be "IS NOT NULL", "IS NULL", or ""
dedup_filter="" # Can be "true", "false", or ""
min_length=""
max_length=""

# Use getopts for better option parsing
# The colon after an option indicates it requires an argument (e.g., P:, l:, L:)
# Leading colon tells getopts to handle errors silently (we'll check later)
while getopts ":huUfvtdDl:L:P:" opt; do
    case ${opt} in
    h)
        print_help
        exit 0
        ;;
    u) uuid_flag=true ;;
    U) no_uuid_flag=true ;;
    f) full_cols_flag=true ;;
    v) inverse_match_flag=true ;;
    t)
        if [[ -n "$ts_filter" ]]; then # Check for conflict with -T
            echo "Error: Options -t (--has-designated-timestamp) and -T (--no-designated-timestamp) are mutually exclusive." >&2
            exit 1
        fi
        ts_filter="IS NOT NULL"
        ;;
    T)
        if [[ -n "$ts_filter" ]]; then # Check for conflict with -t
            echo "Error: Options -t (--has-designated-timestamp) and -T (--no-designated-timestamp) are mutually exclusive." >&2
            exit 1
        fi
        ts_filter="IS NULL"
        ;;
    d)
        if [[ -n "$dedup_filter" ]]; then # Check for conflict with -D
            echo "Error: Options -d (--dedup-enabled) and -D (--dedup-disabled) are mutually exclusive." >&2
            exit 1
        fi
        dedup_filter="true"
        ;;
    D)
        if [[ -n "$dedup_filter" ]]; then # Check for conflict with -d
            echo "Error: Options -d (--dedup-enabled) and -D (--dedup-disabled) are mutually exclusive." >&2
            exit 1
        fi
        dedup_filter="false"
        ;;
    l)
        # Basic validation: check if it's a number? Optional.
        if ! [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
            echo "Error: --min-length requires a non-negative integer." >&2
            exit 1
        fi
        min_length="$OPTARG"
        ;;
    L)
        if ! [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
            echo "Error: --max-length requires a non-negative integer." >&2
            exit 1
        fi
        max_length="$OPTARG"
        ;;
    P) partition_by_filter="$OPTARG" ;;
    \?) # Invalid option
        echo "Invalid option: -$OPTARG" >&2
        print_help
        exit 1
        ;;
    :) # Missing argument
        echo "Option -$OPTARG requires an argument." >&2
        print_help
        exit 1
        ;;
    esac
done
shift $((OPTIND - 1)) # Remove parsed options and args from $@

# --- Argument Validation ---
# Enforce mutual exclusivity of UUID flags (again, belt-and-suspenders)
if [[ "$uuid_flag" == true && "$no_uuid_flag" == true ]]; then
    echo "Error: options -u|--uuid and -U|--no-uuid are mutually exclusive." >&2
    exit 1
fi

# The first remaining argument (if any) is the positional regex
regex="${1:-}"
if [[ $# -gt 1 ]]; then
    echo "Error: Too many positional arguments. Only one regex pattern is allowed." >&2
    print_help
    exit 1
fi

# --- Build WHERE Clause ---
conds=()

# Positional Regex Filter
if [[ -n "$regex" ]]; then
    operator="~"
    if [[ "$inverse_match_flag" == true ]]; then
        operator="!~"
    fi
    # Escape single quotes within the regex pattern itself for the SQL string
    safe_regex="${regex//\'/\'\'}"
    conds+=("table_name ${operator} '${safe_regex}'")
fi

# UUID Filter
if [[ "$uuid_flag" == true ]]; then
    conds+=("table_name ~ '${UUID_REGEX}'")
elif [[ "$no_uuid_flag" == true ]]; then
    conds+=("table_name !~ '${UUID_REGEX}'")
fi

# Partition By Filter
if [[ -n "$partition_by_filter" ]]; then
    # Convert comma-separated list to SQL IN ('val1', 'val2') format
    # Replace commas with ','
    sql_in_list=$(echo "$partition_by_filter" | sed "s/,/','/g")
    # Add leading and trailing quotes
    sql_in_list="'${sql_in_list}'"
    conds+=("partitionBy IN (${sql_in_list})")
fi

# Designated Timestamp Filter
if [[ -n "$ts_filter" ]]; then
    conds+=("designatedTimestamp ${ts_filter}")
fi

# Deduplication Filter
if [[ -n "$dedup_filter" ]]; then
    conds+=("dedup = ${dedup_filter}")
fi

# Length Filters
if [[ -n "$min_length" ]]; then
    conds+=("length(table_name) >= ${min_length}")
fi
if [[ -n "$max_length" ]]; then
    conds+=("length(table_name) <= ${max_length}")
fi

# Assemble WHERE clause
if ((${#conds[@]})); then
    # Join conditions with ' AND '
    where_clause="WHERE $(
        IFS=' AND '
        echo "${conds[*]}"
    )"
else
    where_clause=""
fi

# --- Construct and Execute Query ---
# Select columns based on the -f flag
select_cols="table_name"
if [[ "$full_cols_flag" == true ]]; then
    select_cols="*"
fi

# Construct final query
query="SELECT ${select_cols} FROM tables ${where_clause}"

# Prepare base command array
CMD_ARRAY=(qdb-cli exec -q "$query")

# Add output formatting options based on the -f flag
if [[ "$full_cols_flag" == true ]]; then
    CMD_ARRAY+=(--psql) # Add --psql for full columns
else
    CMD_ARRAY+=(-x table_name) # Extract only table_name by default
fi

# Execute the command
# Optional: Print the command if verbose/debug is needed
# echo "Executing: ${CMD_ARRAY[*]}" >&2
"${CMD_ARRAY[@]}"
